(* countable ordinals *)

import {
  type unit :: ⋆
  val unit : unit

  type Nat :: < type t as α :: ⋆
                type Sig :: ⋆ =
                { val Zero : α
                  val Succ : α → α
                  val match : ∀(β::⋆), α →
                      { val Zero : unit → β
                        val Succ : α → β    } → β
                 }
               >
  val Nat : Nat.Sig

  type Ord_Sig :: ⋆ ⇒ ⋆ = λ (α :: ⋆) ⇒
    { val Zero : α
      val Succ : α → α
      val Lim  : (Nat.t → α) → α
      val match : ∀(β::⋆), α →
          { val Zero : unit → β
            val Succ : α → β
            val Lim  : (Nat.t → α) → β } → β
    }

}

export {
  type Ord :: < type t as t :: ⋆
                type Sig :: ⋆ = Ord_Sig t >
}

let type Ord_Constr (α :: ⋆) :: ⋆ =
  { val Zero : α
    val Succ : α → α
    val Lim  : (Nat.t → α) → α } in
let type ord :: ⋆ = ∀ (α :: ⋆), Ord_Constr α → α in

Σ [Ord] (Ord :: < type t as t :: ⋆ type Sig :: ⋆ = Ord_Sig t >
              = < type t = ord     type Sig = Ord_Sig ord >)
(let mkZero (α :: ⋆) (r : Ord_Constr α) : α = r.Zero in
let mkSucc (O : ord) (α :: ⋆) (r : Ord_Constr α) : α = r.Succ (O [α] r) in
let mkLim (f : Nat.t → ord) (α :: ⋆) (r : Ord_Constr α) : α =
  r.Lim (λ (n : Nat.t) → (f n) [α] r) in
{ val Zero = mkZero
  val Succ = mkSucc
  val Lim  = mkLim
  val match (β :: ⋆) (O : ord)
             (destruct :
               { val Zero : unit → β
                 val Succ : ord → β
                 val Lim  : (Nat.t → ord) → β }) =
             let y = O [{ val ord: ord val res: β }]
             { val Zero = { val ord = mkZero val res = destruct.Zero unit }
               val Succ (x : { val ord: ord val res: β }) =
                  { val ord = mkSucc x.ord val res = destruct.Succ x.ord }
               val Lim (f : Nat.t → { val ord: ord val res: β }) =
                  { val ord = mkLim (λ (n : Nat.t) → (f n).ord)
                    val res = destruct.Lim (λ (n : Nat.t) → (f n).ord) }
             } in
             y.res
} : Ord_Sig Ord.t)
