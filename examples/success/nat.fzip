(* encoding of natural numbers *)

import {
  type unit :: ⋆
  val unit : unit

  type nat_sig ::
  S (λ(α::⋆) ⇒ { val Zero : α
                  val Succ : α → α
                  val match : ∀(β::⋆), α →
                      { val Zero : unit → β
                        val Succ : α → β    } → β
                 }
    :: ⋆ ⇒ ⋆)
}

export {
  type Nat :: < type t as t :: ⋆
                type Sig :: S(nat_sig t) >
}

let type nat_constr (α::⋆) :: ⋆ = { val Zero : α val Succ : α → α } in
let type nat :: ⋆ = ∀(α::⋆), nat_constr α → α in

Σ [Nat] (Nat
          :: < type t as t :: ⋆ type Sig :: S(nat_sig t) >
          = < type t = nat type Sig = nat_sig nat >)
({ val Zero (α :: ⋆) (r : nat_constr α) = r.Zero
   val Succ (n : nat) (α :: ⋆) (r : nat_constr α) =
       n [α] { val Zero = r.Succ r.Zero val Succ = r.Succ }
   val match (β :: ⋆) (n : nat)
             (destruct : { val Zero : unit → β val Succ : nat → β }) =
             n [β]
             { val Zero = destruct.Zero unit
               val Succ (x : β) = destruct.Succ n }
} : nat_sig Nat.t)
